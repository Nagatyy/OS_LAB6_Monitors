#include <QThread>
#include <QMutex>
#include <QMutexLocker>
#include <QWaitCondition>
#include <iostream>

using namespace std;

#define BUFFERSIZE 10


class Monitor {
private:
    QMutex mutex;
    QWaitCondition producerWait;
    QWaitCondition consumerWait;
    int buffer[BUFFERSIZE];
    int currentNumOfItemsInBuffer;
    int in, out;
    int numOfNumbersProducedSoFar;
    int totalNumbersToBeProduced;


public:
    Monitor(int totalNumbersToBeProduced){
        currentNumOfItemsInBuffer = 0;
        in = 0;
        out = 0;
        numOfNumbersProducedSoFar = 0;
        this -> totalNumbersToBeProduced = totalNumbersToBeProduced;
    }

    void read(int& item){
        QMutexLocker locker(&mutex);
        while(currentNumOfItemsInBuffer == 0){
            cout << "No Items to read!\n";
            consumerWait.wait(&mutex);
        }
        item = buffer[out];
        currentNumOfItemsInBuffer--;
        out = (out + 1) % BUFFERSIZE;
        producerWait.wakeAll();

    }

    void write(int item){
        QMutexLocker locker(&mutex);
        while(currentNumOfItemsInBuffer == BUFFERSIZE && numOfNumbersProducedSoFar != totalNumbersToBeProduced){
            cout << "Buffer is full\n";
            producerWait.wait(&mutex);
        }

        // exit condition -> write -1s

        cout << numOfNumbersProducedSoFar << endl;
        if(numOfNumbersProducedSoFar == totalNumbersToBeProduced){
            buffer[in++] = -1;
            in %= BUFFERSIZE;
            currentNumOfItemsInBuffer++;
        }
        else {
            buffer[in++] = item;
            in %= BUFFERSIZE;
            currentNumOfItemsInBuffer++;
            numOfNumbersProducedSoFar++;
        }

        consumerWait.wakeAll();

    }


};

//===============================================
class Producer : public QThread
{
private:
    int total;      // number of random numbers to generated by this producer
    int ID;
    Monitor* monitor;
    QMutex ctrl;    // only used to lock output stream
public:
    Producer(int ID, int total, Monitor* m) {     
        this -> ID = ID;
        this -> total = total;
        monitor = m;
        ctrl.lock();
        cout << "Producer " << ID << " will generate " << total << " random numbers" << endl;
        ctrl.unlock();
        srand(time(0));                

    }
    void run(){
        for (int j = 0; j < total; j++){
            int random = rand();
            monitor -> write(random);
            ctrl.lock();
            cout << "Producer Thread " << ID << "wrote a number\n"; 
            ctrl.unlock();
        }
    }
};


//===============================================
class Consumer : public QThread
{
private:
    int ID;
    Monitor* monitor;
    QMutex ctrl; // only used to lock output stream
public:
    Consumer(int ID, Monitor* m) {
        this -> ID = ID;
        monitor = m;
    } 
    void run(){
        int item;
        int nread = 0;
        while (1){
            monitor -> read(item);
            ctrl.lock();
            cout << "Consumer Thread " << ID << "read a number\n"; 
            ctrl.unlock();
            nread++;           
            if (item < 0) 
                break;              
        }
        ctrl.lock();
        cout << "Consumer Thread " << ID << " read a total of " << nread << endl;
        ctrl.unlock();
    }
};

//================================================
int main(int argc, char** argv){

    srand(time(0)); 

     if (argc != 4){
        std::cout << "Incorrect Number of Arguments!" <<std::endl;
        return 0; 
    }
    
    int M = atoi(argv[1]);                 // num of producer threads
    int N = atoi(argv[2]);                  // num of consumer threads               
    int NUM = atoi(argv[3]);               // total number of random numbers to be generated


    Monitor monitor(NUM);           // the monitor knows the tootal number of random numbers to be generated
    Producer* p[M];                 // M producer threads
    Consumer* c[N];                 // N consumer threads

    int numbersToProduce;
    int totalNumbersProduced = 0;   // to hold the number of numbers produced so far  

    for(int i = 0; i < M; i++){

        // the last producer thread will proeduce NUM - total numbers produced
        if(i == M-1){ 
            p[i] = new Producer(i, NUM - totalNumbersProduced, &monitor);
            p[i] -> start();
        }
        else {
            numbersToProduce = rand() % (NUM - totalNumbersProduced);
            totalNumbersProduced+= numbersToProduce;
            p[i] = new Producer(i, numbersToProduce, &monitor);
            p[i] -> start();
        }
    }
    
    for (int i = 0; i < N; i++) {
        c[i] = new Consumer(i, &monitor);
        c[i]->start();
    }

    for(int i = 0; i < M; i++)
        p[i] -> wait();


    for (int i = 0; i < N; i++)
        c[i]->wait();           // wait for the consumer threads

    return 0;
}